function [] = BAMRlExploit(W, V, reinf)

OuvrirNXT
eta = .1; %Paramètre d'apprentissage du BAM
delta = .5;
global h j
[Xall Yall Ux Sx Vx Uy Sy Vy] = allPossibleInputs3();

%% Phase d'exploitation (prévision future à l'aide de 3 BAM)
superColourVExploit = -ones(100, 1);
colourScalar=GetColor(SENSOR_2, 0, j);
colourV1 = colourVector(colourScalar);
superColourVExploit(1, 1) = colourScalar;
historique = 1;
while colourV1(reinf,1) ~= 1
    Rsequencelist=[];
    for i = 1:4
        for jj = 1:4
            for k = 1:4
                ActionV1 = -ones(4,1);
                ActionV1(i,1)=1;
                X1=vertcat(colourV1,ActionV1);
                XPosition=find(all(repmat(X1,1,size(Xall,2))==Xall));
                Xin1=Ux(XPosition,:);%Orthogonalisation du vecteur d'entrée
                [Xout1 Yout1 colourV1out ActionV1out colourV2out R1out] = BAMout2(Xin1,W,V,5,0.5);
                
                for m=1:40
                    DifList(1,m)=norm(Yout1./norm(Yout1)-Uy(m,:)');
                end
                [Valeur YPosition]= min(DifList);
                Yvector1=Yall(:,YPosition);% Désorthogonalisation du vecteur de sortie
                
                ActionV2 = -ones(4,1);
                ActionV2(jj,1)=1;
                
                X2 = vertcat(Yvector1(1:10,1),ActionV2);%Création du vecteur d'entré pour le 2e BAM
                XPosition=find(all(repmat(X2,1,size(Xall,2))==Xall));
                Xin2=Ux(XPosition,:);%Orthogonalisation du vecteur d'entré
                [Xout2 Yout2 colourV2out ActionV2out colourV3out R2out] = BAMout2(Xin2,W,V,5,0.5);
                
                
                for m=1:40
                    DifList(1,m)=norm(Yout2./norm(Yout2)-Uy(m,:)');
                end
                [Valeur YPosition]= min(DifList);
                Yvector2=Yall(:,YPosition);
                
                ActionV3 = -ones(4,1);
                ActionV3(k,1)=1;
                
                X3 = vertcat(Yvector2(1:10,1),ActionV3);
                XPosition=find(all(repmat(X3,1,size(Xall,2))==Xall));
                Xin3=Ux(XPosition,:);
                
                [Xout3 Yout3 colourV3out ActionV3out colourV4out R3out] = BAMout2(Xin3,W,V,5,0.5);
                
                for m=1:40
                    DifList(1,m)=norm(Yout3./norm(Yout3)-Uy(m,:)');
                end
                [Valeur YPosition]= min(DifList);
                Yvector3=Yall(:,YPosition);
                
                R1out  = Yvector1(11:14,1);
                R2out = Yvector2(11:14,1);
                R3out = Yvector3(11:14,1);
                
                if sum(R1out)==-4 || sum(R2out)==-4 || sum(R3out)==-4
                    Rsequence=[-Inf -Inf -Inf];
                else
                    Rsequence=[sum(R1out) sum(R2out) sum(R3out)]; % Création du vecteur contenant les 3 rewards prévus
                end
                
                Rsequencelist=[Rsequencelist;Rsequence];
                
            end
        end
    end
    %% Sélection de la séquence d'actions à poser
    Z=actCubT(0.1*Rsequencelist*[0.8;0.8^2;0.8^3],delta)';
    [WinnerZ indiceWinnerZ]=max(Z);
    MatriceAction=[1 1 1; 1 1 2; 1 1 3; 1 1 4; 1 2 1; 1 2 2; 1 2 3; 1 2 4; 1 3 1; 1 3 2; 1 3 3; 1 3 4; 1 4 1; 1 4 2; 1 4 3; 1 4 4;
        2 1 1; 2 1 2; 2 1 3; 2 1 4; 2 2 1; 2 2 2; 2 2 3; 2 2 4; 2 3 1; 2 3 2; 2 3 3; 2 3 4; 2 4 1; 2 4 2; 2 4 3; 2 4 4;
        3 1 1; 3 1 2; 3 1 3; 3 1 4; 3 2 1; 3 2 2; 3 2 3; 3 2 4; 3 3 1; 3 3 2; 3 3 3; 3 3 4; 3 4 1; 3 4 2; 3 4 3; 3 4 4;
        4 1 1; 4 1 2; 4 1 3; 4 1 4; 4 2 1; 4 2 2; 4 2 3; 4 2 4; 4 3 1; 4 3 2; 4 3 3; 4 3 4; 4 4 1; 4 4 2; 4 4 3; 4 4 4];
    
    ActSeq=MatriceAction(indiceWinnerZ,:);
    if colourV1(reinf,1) ~= 1;
			compassScalar=GetCompass(SENSOR_1, h);%+diff.orient;
			actionDo2(ActSeq(1,1),compassScalar);
			colourScalar=GetColor(SENSOR_2, 0, j);
			colourV1 = colourVector(colourScalar);
			historique = historique+1;
			superColourVExploit(historique, 1) = colourScalar;
			if colourV1(9,1) == 1;    
				reculer;  
			end
	end
	end
end